##############################################################################
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################


# This workflow runs in both the trusted base repository at
# https://www.github.com/FAIR-GROUND/App/actions as well as in
# any forks that have enabled actions. The latter workflow
# will build the app and create a release in the fork's repository,
# while the workflow in the base repository will
# build the app a second time in a trusted environment and,
# if the two binaries match, publish a `fairseal` hash of
# the release artifacts for verification by the App Fair catalog
# browser app, as well as optionally publish the app to external channels.
#
# See https://www.appfair.net for more details.
name: "fair-ground"

env:
  FAIRGROUND: "appfair"
  APP_TARGET: "AppFairApp"
  PREFLIGHT_BUNDLE_PREFIX: "org.appfair"
  FAIRGROUND_LAUNCHPAD: "https://appfair.app/fair?app="

  HUB_REPO: "github.com"
  HUB_PAGE: "github.io"

  # installed from https://github.com/fair-ground/homebrew-tool release
  FAIRTOOL: "fairtool"
  # fairtool-head will build from source, which adds a few minutes
  #FAIRTOOL: "fairtool-head"
  # uses the tool from the App's Package.swift source with swift run fairtool
  #FAIRTOOL: "swift run fairtool"

  DEVELOPER_DIR: /Applications/Xcode_14.1.app/Contents/Developer

on:
  workflow_call:
    inputs:
      # the name of the fairground organization (e.g., "appfair")
      fairground:
        required: false
        type: string
        default: appfair
      # the name of the bot that posts fairseals to PRs that pass integration
      fairseal_issuer:
        required: false
        type: string
      # the license that fairground projects must adhere to
      license:
        required: false
        type: string
        default: AGPL-3.0
      # whether to create macOS products
      target_macos:
        type: boolean
        required: false
        default: true
      # whether to create iOS products
      target_ios:
        type: boolean
        required: false
        default: true
      # whether to create tvOS products
      target_tvos:
        type: boolean
        required: false
        default: false
      # whether to create watchOS products
      target_watchos:
        type: boolean
        required: false
        default: false
      # whether to create linux products
      target_linux:
        type: boolean
        required: false
        default: false
      # whether to create windows products
      target_windows:
        type: boolean
        required: false
        default: false

    secrets:
      # Build App secrets
      NOTARY_TEAMID:
        required: false
      NOTARY_USERID:
        required: false
      NOTARY_PASSWORD:
        required: false
      NOTARY_CERTKEY_P12_BASE64:
        required: false
      NOTARY_CERTKEY_PASSWORD:
        required: false

      # Replicate-Release secrets
      APP_FAIR_BOT_TOKEN:
        required: false
      APP_FAIR_ALLOW_NAME:
        required: false
      APP_FAIR_DENY_NAME:
        required: false
      APP_FAIR_ALLOW_FROM:
        required: false
      APP_FAIR_DENY_FROM:
        required: false
      APP_FAIR_FAIRSEAL_KEY:
        required: false

      TESTFLIGHT_TEAMID:
        required: false
      TESTFLIGHT_ISSUER_ID:
        required: false
      TESTFLIGHT_KEY_ID:
        required: false
      TESTFLIGHT_KEY_CONTENTS:
        required: false
      TESTFLIGHT_CODESIGNING_IDENTITY:
        required: false

jobs:
  # The Build App phases run in the /App.git fork's repository.
  # This workflow builds and validates the app, and if a semver tag 
  # tag is pushed, it will also create a release and publish the artifacts.
  # Released artifacts will only be published in the App Fair catalog
  # once the Replicate Release phases (below) are successfully run
  # and a fairseal is published.
  build_app:
    name: "Build App"
    #if: github.repository_owner != 'appfair' && github.event_name != 'pull_request_target'
    if: github.event_name != 'pull_request_target'
    runs-on: macos-12
    timeout-minutes: 120
    steps:
      - name: "Initialize fair-ground"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "$GITHUB_CONTEXT"
          echo "ORGNAME=${{ github.repository_owner }}" >> $GITHUB_ENV
          echo "APP_NAME=$(echo ${{ github.repository_owner }} | sed 's;^${{ env.FAIRGROUND }}$;App-Name;g')" >> $GITHUB_ENV
          echo "COMMITHASH=${{ github.sha }}" >> $GITHUB_ENV

      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: "Install fairtool formula"
        if: env.FAIRTOOL != 'swift run fairtool'
        run: brew install fair-ground/tool/$FAIRTOOL

      - name: "Check ${{ env.FAIRTOOL }} version"
        run: $FAIRTOOL version

      - name: "Configure App: ${{ env.APP_NAME }}"
        id: platforms
        run: |
          $FAIRTOOL app configure -p . > .appconfig.json

          echo "FAIR_APP_ARTIFACT=${{ env.APP_NAME }}" >> $GITHUB_ENV

          echo "PRODUCT_NAME="$(cat .appconfig.json | jq -r '.[].productName') >> $GITHUB_ENV
          echo "BUNDLE_ID="$(cat .appconfig.json | jq -r '.[].bundleIdentifier') >> $GITHUB_ENV
          echo "APP_VERSION="$(cat .appconfig.json | jq -r '.[].version') >> $GITHUB_ENV
          echo "APP_BUILD_NUMBER="$(cat .appconfig.json | jq -r '.[].buildNumber') >> $GITHUB_ENV

          echo "macos="$(cat .appconfig.json | jq -r '.[].supportedPlatforms' | grep 'macosx' > /dev/null && echo enabled || echo disabled) >> $GITHUB_OUTPUT
          echo "ios="$(cat .appconfig.json | jq -r '.[].supportedPlatforms' | grep 'iphoneos' > /dev/null && echo enabled || echo disabled) >> $GITHUB_OUTPUT

      - name: "Validate ${{ env.APP_NAME }} ${{ env.APP_VERSION }} (${{ env.APP_BUILD_NUMBER }})"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $FAIRTOOL app refresh --project .
          $FAIRTOOL fair validate --verbose --hub "${HUB_REPO}/${{ inputs.fairground }}" --org "${ORGNAME}" --base . --project . --fair-properties "$FAIRGROUND.xcconfig" --allow-license "AGPL-3.0"
          $FAIRTOOL fair icon --org "${ORGNAME}" --fair-properties $FAIRGROUND.xcconfig --accent-color Assets.xcassets/AccentColor.colorset/Contents.json --app-icon Assets.xcassets/AppIcon.appiconset/Contents.json
          mkdir staging/

      # Verifies that the project URLs are configured correctly
      - name: "Verify Project http://${{ env.ORGNAME }}.appfair.net"
        if: env.ORGNAME != 'appfair'
        run: |
          # check both the *.github.io and *.appfair.net URLs
          curl --location --fail -s "https://${ORGNAME}.${HUB_PAGE}/App" | grep "$FAIRGROUND_LAUNCHPAD""${ORGNAME}"
          if [ "${ORGNAME}" != "App-Fair" ]; then
            # note that we check http and not https because the site's
            # SSL configuration may not have completed yet
            curl --location --fail -s "http://${ORGNAME}.appfair.net" | grep "$FAIRGROUND_LAUNCHPAD""${ORGNAME}"
          fi

      - name: "Resolve Swift Packages"
        run: |
          xcrun swift package resolve
          cat Package.resolved
          cp Package.resolved Sources/App/Resources/

      - name: "Test iOS App"
        # need to set up test scheme to make this work
        if: steps.platforms.outputs.ios == 'enabled'
        run: |
          set -o pipefail && env NSUnbufferedIO=YES \
            xcodebuild test -configuration Release -workspace "App.xcworkspace" -scheme "AppFairApp" -sdk "iphonesimulator" -destination "platform=iOS Simulator,name=iPhone 14" \
            | xcpretty

          # check to ensure screenshots folders exists
          ls -la ~/Library/Developer/CoreSimulator/Devices/*/data/Library/Caches/com.apple.dt.xctest.tool || true
          ls -la ~/Library/Developer/CoreSimulator/Devices/*/data/Library/Caches/com.apple.dt.xctest.tool/screenshots || true
          find ~/Library/Developer/CoreSimulator/Devices/*/data/Library/Caches/com.apple.dt.xctest.tool/screenshots -type f || true

          # Copy the screenshots to the docs/ folder
          # rm -rf docs/screenshots && mv ~/Library/Developer/CoreSimulator/Devices/*/data/Library/Caches/com.apple.dt.xctest.tool/screenshots docs/screenshots && ls -la docs/screenshots

      # Create a new release for this tag
      - name: "Create Release"
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating release: ${GITHUB_REF#refs/tags/}"
          # create a pre-release if it doesn't already exist 
          gh release create "${GITHUB_REF#refs/tags/}" --prerelease --title "Release ${GITHUB_REF#refs/tags/}" --generate-notes || true

      - name: "Upload iOS Screenshots"
        if: steps.platforms.outputs.ios == 'enabled' && startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cp -a ~/Library/Developer/CoreSimulator/Devices/*/data/Library/Caches/com.apple.dt.xctest.tool/screenshots staging/screenshots || mkdir -p staging/screenshots
          # create a zip of the screenshots in staging
          ditto -c -k --keepParent staging/screenshots "${FAIR_APP_ARTIFACT}-iOS-screenshots.zip"

          ls -lah "${FAIR_APP_ARTIFACT}-iOS-screenshots.zip"

          # upload staging assets to the existing GitHub release
          gh release upload "${GITHUB_REF#refs/tags/}" -- "${FAIR_APP_ARTIFACT}-iOS-screenshots.zip"

      - name: "Archive iOS App"
        if: steps.platforms.outputs.ios == 'enabled'
        run: |
          set -o pipefail && env NSUnbufferedIO=YES \
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -jobs 1 \
            -configuration Release \
            -scheme "${APP_TARGET}" \
            -sdk "iphoneos" \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-iOS.xcarchive" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            FAIRAPP_PRODUCT_NAME="${PRODUCT_NAME}" \
            | xcpretty

          cp -a "staging/.${FAIR_APP_ARTIFACT}-iOS.xcarchive/Products/Applications" "staging/Payload"

          # create the zip file with predictable timestamps
          TAGDATE="$(git log -1 --format=%ad --date=iso-strict ${GITHUB_REF#refs/tags/})"
          find "staging/Payload" -exec touch -d "${TAGDATE:0:19}" {} \;
          ditto -c -k --sequesterRsrc --keepParent "staging/Payload" "${FAIR_APP_ARTIFACT}-iOS.ipa"
          ls -la "${FAIR_APP_ARTIFACT}-iOS.ipa"
          shasum -a 256 "${FAIR_APP_ARTIFACT}-iOS.ipa"


      - name: "Upload iOS Release"
        if: steps.platforms.outputs.ios == 'enabled' && startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "${GITHUB_REF#refs/tags/}" -- "${FAIR_APP_ARTIFACT}-iOS.ipa"

      - name: "Test macOS App"
        if: steps.platforms.outputs.macos == 'enabled'
        run: |
          set -o pipefail && env NSUnbufferedIO=YES \
            xcodebuild test -configuration Release -workspace "App.xcworkspace" -scheme "AppFairApp" -sdk "macosx" -destination "platform=macosx" \
            | xcpretty

      - name: "Archive macOS App"
        if: steps.platforms.outputs.macos == 'enabled'
        run: |
          # needed to be able to ad-hoc codesign embedded frameworks
          plutil -replace 'com\.apple\.security\.cs\.disable-library-validation' -bool true sandbox-macos.entitlements

          set -o pipefail && env NSUnbufferedIO=YES \
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -jobs 1 \
            -configuration Release \
            -scheme "${APP_TARGET}" \
            -sdk "macosx" \
            -destination "platform=macOS" \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-macOS.xcarchive" \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            DEVELOPMENT_TEAM="" \
            CODE_SIGN_IDENTITY="-" \
            OTHER_CODE_SIGN_FLAGS="--deep --timestamp=none" \
            OTHER_LIBTOOLFLAGS="-D" \
            FAIRAPP_PRODUCT_NAME="${PRODUCT_NAME}" \
            | xcpretty

          echo '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict><key>method</key><string>mac-application</string><key>signingStyle</key><string>automatic</string><key>uploadBitcode</key><false/><key>compileBitcode</key><false/><key>uploadSymbols</key><false/></dict></plist>' > "staging/.exportOptions.plist"

          xcodebuild \
            -exportArchive \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-macOS.xcarchive" \
            -exportPath "staging/" \
            -exportOptionsPlist "staging/.exportOptions.plist"

          codesign --verify --verbose=5 "staging/${PRODUCT_NAME}.app"
          codesign -dv --verbose=5 "staging/${PRODUCT_NAME}.app"
          codesign -d --entitlements - "staging/${PRODUCT_NAME}.app"

          # create the zip file with predictable timestamps
          TAGDATE="$(git log -1 --format=%ad --date=iso-strict ${GITHUB_REF#refs/tags/})"
          find "staging/${PRODUCT_NAME}.app" -exec touch -d "${TAGDATE:0:19}" {} \;
          ditto -c -k --sequesterRsrc --keepParent "staging/${PRODUCT_NAME}.app" "${FAIR_APP_ARTIFACT}-macOS.zip"
          ls -la "${FAIR_APP_ARTIFACT}-macOS.zip"
          shasum -a 256 "${FAIR_APP_ARTIFACT}-macOS.zip"

      # Notarization is not required for the App Fair, but a developer
      # can opt to notarize their own build which will allow them to 
      # distribute the app outside of the App Fair without having to
      # make a separate notarized release.
      #
      # See: https://docs.github.com/en/actions/deployment/deploying-xcode-applications/installing-an-apple-certificate-on-macos-runners-for-xcode-development
      - name: "Check Notarization Keys"
        id: notarization_setup
        env:
            NOTARY_TEAMID: ${{ secrets.NOTARY_TEAMID }}
        if: env.NOTARY_TEAMID != '' && startsWith(github.ref, 'refs/tags/')
        # transfer the secret to an env variable so it can be checked with `if`
        run: echo "::set-output name=defined::true"

      - name: "Notarize App"
        if: steps.notarization_setup.outputs.defined == 'true'
        run: |
          security delete-keychain fairsign.keychain || true
          security create-keychain -p "${{ secrets.NOTARY_CERTKEY_PASSWORD }}" fairsign.keychain
          security default-keychain -s fairsign.keychain
          security list-keychains -s fairsign.keychain

          # import certificate
          mkdir -p .notarization
          echo "${{ secrets.NOTARY_CERTKEY_P12_BASE64 }}" | base64 -d -o .notarization/certificate.p12
          security import .notarization/certificate.p12 -k fairsign.keychain -A -P "${{ secrets.NOTARY_CERTKEY_PASSWORD }}"
          rm -rf .notarization

          security set-key-partition-list -S "apple-tool:,apple:,codesign:" -s -k "${{ secrets.NOTARY_CERTKEY_PASSWORD }}" fairsign.keychain

          # show valid identities
          security find-identity -v

          # re-sign the app with the imported certificate and the identity
          codesign --force --deep -v --options runtime --entitlements "sandbox-macos.entitlements" -s "`security find-identity -v | cut -f 4 -d ' ' | head -n 1`" "staging/${PRODUCT_NAME}.app"

          # re-create the archive with the signed app for submission
          ditto -c -k --sequesterRsrc --keepParent "staging/${PRODUCT_NAME}.app" "${FAIR_APP_ARTIFACT}-macOS.zip"

          # perform notarization and wait for success
          xcrun notarytool submit --wait --progress --apple-id "${{ secrets.NOTARY_USERID }}" --password "${{ secrets.NOTARY_PASSWORD }}" --team-id "${{ secrets.NOTARY_TEAMID }}" "${FAIR_APP_ARTIFACT}-macOS.zip"

          # staple the notarization ticket to the app
          xcrun stapler staple "staging/${PRODUCT_NAME}.app"

          # re-create the archive with the signed & stapled artifact
          # create the zip file with predictable timestamps
          TAGDATE="$(git log -1 --format=%ad --date=iso-strict ${GITHUB_REF#refs/tags/})"
          find "staging/${PRODUCT_NAME}.app" -exec touch -d "${TAGDATE:0:19}" {} \;

          ditto -c -k --sequesterRsrc --keepParent "staging/${PRODUCT_NAME}.app" "${FAIR_APP_ARTIFACT}-macOS.zip"
          ls -la "${FAIR_APP_ARTIFACT}-macOS.zip"
          shasum -a 256 "${FAIR_APP_ARTIFACT}-macOS.zip"

      - name: "Upload macOS Release"
        if: steps.platforms.outputs.macos == 'enabled' && startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "${GITHUB_REF#refs/tags/}" -- "${FAIR_APP_ARTIFACT}-macOS.zip"

      - name: "Upload Release Assets"
        if: startsWith(github.ref, 'refs/tags/')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # Extract the Info.plist from the archives themselves, since they contain
        # the same post-processed metadata that the app will use.
        # Convert plists to XML for easier parsing.
        run: |
          cp Assets.xcassets/AppIcon.appiconset/appicon-iphone-60x60@3x.png staging/"${FAIR_APP_ARTIFACT}.png"
          cp App.yml staging/
          cp Info.plist staging/

          ls -la staging/

          echo "Uploading release assets: ${GITHUB_REF#refs/tags/}"

          # log the checksum for each of the staging elements
          openssl sha256 -- $(find staging -maxdepth 1 -type f)

          # upload staging assets to the existing GitHub release
          gh release upload "${GITHUB_REF#refs/tags/}" -- $(find staging -maxdepth 1 -type f)


      - name: "Upload Build Artifacts"
        # upload the trusted artifacts for each build for reproducible-builds
        uses: actions/upload-artifact@v2
        if: always()
        with:
          path: staging


  # The Replicate Release phases run in the trusted base fairground.
  # This workflow validates and re-builds the app, and if the artifact hash
  # matches that of the public release, it will publish the fairseal
  # required for inclusion in the catalog.  
  replicate_release:
    name: "Replicate Release"
    if: github.repository_owner == 'appfair' && github.event_name == 'pull_request_target'
    runs-on: macos-12
    timeout-minutes: 120
    steps:
      - name: "Initialize fair-ground"
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "$GITHUB_CONTEXT"

          echo "PRTITLE=${{ github.event.pull_request.title }}" >> $GITHUB_ENV
          echo "ORGNAME=${{ github.event.pull_request.head.user.login }}" >> $GITHUB_ENV
          echo "COMMITHASH=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV
          echo "PRID=${{ github.event.pull_request.id }}" >> $GITHUB_ENV

      - name: "Close Pull Request"
        # Pull Requests are always immediately closed
        # Re-builds can be initiated by re-opening the PR or making a new one.
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh pr close --comment "Integrating and publishing contribution ${{ github.event.pull_request.patch_url }} with workflow ${{ github.event.pull_request.base.repo.html_url }}/actions/runs/${{ github.run_id }}." ${{ github.event.pull_request.html_url }}

      - name: "Checkout Base Fairground"
        uses: actions/checkout@v3

      - name: "Install fairtool formula"
        if: env.FAIRTOOL != 'swift run fairtool'
        run: brew install fair-ground/tool/$FAIRTOOL

      - name: "Check ${{ env.FAIRTOOL }}"
        run: $FAIRTOOL version

      # Verifies that the project URLs are configured correctly
      - name: "Verify Project http://${{ env.ORGNAME }}.appfair.net"
        run: |
          # check both the App.github.io and App.appfair.net URLs
          curl --location --fail -s "https://${ORGNAME}.${HUB_PAGE}/App" | grep "$FAIRGROUND_LAUNCHPAD""${ORGNAME}"
          if [ "${ORGNAME}" != "App-Fair" ]; then
            curl --location --fail -s "http://${ORGNAME}.appfair.net" | grep "$FAIRGROUND_LAUNCHPAD""${ORGNAME}"
          fi

      - name: "Checkout Integration Pull Request"
        uses: actions/checkout@v3
        with:
          path: ReleasePR
          ref: ${{ env.COMMITHASH }}
          fetch-depth: 0

      - name: "Configure Fork: ${{ env.ORGNAME }}"
        id: platforms
        run: |
          $FAIRTOOL app configure -p ReleasePR/ > .appconfig.json

          echo "FAIR_APP_ARTIFACT=${{ env.ORGNAME }}" >> $GITHUB_ENV

          echo "PRODUCT_NAME="$(cat .appconfig.json | jq -r '.[].productName') >> $GITHUB_ENV
          echo "BUNDLE_ID="$(cat .appconfig.json | jq -r '.[].bundleIdentifier') >> $GITHUB_ENV
          echo "APP_VERSION="$(cat .appconfig.json | jq -r '.[].version') >> $GITHUB_ENV
          echo "APP_BUILD_NUMBER="$(cat .appconfig.json | jq -r '.[].buildNumber') >> $GITHUB_ENV

          echo "macos="$(cat .appconfig.json | jq -r '.[].supportedPlatforms' | grep 'macosx' > /dev/null && echo enabled || echo disabled) >> $GITHUB_OUTPUT
          echo "ios="$(cat .appconfig.json | jq -r '.[].supportedPlatforms' | grep 'iphoneos' > /dev/null && echo enabled || echo disabled) >> $GITHUB_OUTPUT


      #- name: Verify workflow integrity
      # the workflows must be identical; fetch & merge upstream if this fails
      #run: |
      # workflows may not be modified
      #diff -r .github/workflows/ ReleasePR/.github/workflows/

      - name: "Validate ${{ env.ORGNAME }} ${{ env.APP_VERSION }} (${{ env.APP_BUILD_NUMBER }})"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $FAIRTOOL fair validate --base .  --project ReleasePR --hub "${HUB_REPO}/${{ inputs.fairground }}" --base-repo "App" --org "${ORGNAME}" --ref "${COMMITHASH}" --integration-title "${PRTITLE}" --fair-properties "$FAIRGROUND.xcconfig" --fairseal-issuer "${{ inputs.fairseal_issuer }}" --fairseal-key "${{ secrets.APP_FAIR_FAIRSEAL_KEY }}" --allow-name "${{ secrets.APP_FAIR_ALLOW_NAME }}" --deny-name "${{ secrets.APP_FAIR_DENY_NAME }}" --allow-from "${{ secrets.APP_FAIR_ALLOW_FROM }}" --deny-from "${{ secrets.APP_FAIR_DENY_FROM }}" --verbose

          mkdir staging/

      - name: "Resolve Swift Packages"
        run: |
          xcrun swift package resolve
          cat Package.resolved
          cp Package.resolved Sources/App/Resources/

      - name: "Replicate PR"
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}
        run: |
          $FAIRTOOL fair merge --verbose --hub "${HUB_REPO}/${{ inputs.fairground }}" --org "${ORGNAME}" --base . --project ReleasePR --fair-properties "$FAIRGROUND.xcconfig" --output .

          file Assets.xcassets/AppIcon.appiconset/*.*

          # needed to be able to ad-hoc codesign embedded frameworks
          plutil -replace 'com\.apple\.security\.cs\.disable-library-validation' -bool true sandbox-macos.entitlements

          $FAIRTOOL fair validate --hub "${HUB_REPO}/${{ inputs.fairground }}" --org "${ORGNAME}" --base . --project . --fair-properties "$FAIRGROUND.xcconfig" --allow-license "AGPL-3.0"

          xcrun swift package resolve
          cat Package.resolved # useful for the log
          cp Package.resolved Sources/App/Resources/ # embed in the app

          cp -a .build/checkouts Dependencies
          tar cvzf "staging/${FAIR_APP_ARTIFACT}-source.tgz" --exclude='.git/' --exclude='.build/' --exclude='staging/' .
          rm -rf Dependencies

          $FAIRTOOL app refresh
          $FAIRTOOL fair icon --org "${ORGNAME}" --fair-properties "$FAIRGROUND.xcconfig" --accent-color Assets.xcassets/AccentColor.colorset/Contents.json --app-icon Assets.xcassets/AppIcon.appiconset/Contents.json

      - name: "Stage Release Metadata"
        # copy over the un-processed assets from the ReleasePR/
        run: |
          cp README.md staging/
          cp LICENSE.AGPL staging/
          cp LICENSE_EXCEPTION.FAIR staging/
          cp CONTRIBUTION.txt staging/

          cp App.yml staging/
          cp Package.resolved staging/
          # cp Info.plist staging/
          # cp sandbox-macos.entitlements staging/
          # cp sandbox-ios.entitlements staging/

          cp Assets.xcassets/AppIcon.appiconset/appicon-iphone-60x60@3x.png staging/"${FAIR_APP_ARTIFACT}.png"

          cp docs/screenshots/screenshot*-[0-9]*x[0-9]*.png staging/ || true
          cp docs/screenshots/screenshot*-[0-9]*x[0-9]*.jpg staging/ || true

          ls -la staging/
          # log the checksum for each of the staging elements
          # or true is there is case of directories
          #shasum -a 256 staging/*.*

      - name: "Archive iOS App"
        if: steps.platforms.outputs.ios == 'enabled'
        run: |
          set -o pipefail && env NSUnbufferedIO=YES \
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -jobs 1 \
            -configuration Release \
            -scheme "${APP_TARGET}" \
            -sdk "iphoneos" \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-iOS.xcarchive" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            FAIRAPP_PRODUCT_NAME="${PRODUCT_NAME}" \
            | xcpretty

          cp -a "staging/.${FAIR_APP_ARTIFACT}-iOS.xcarchive/Products/Applications" "staging/Payload"

          # create the zip file with predictable timestamps

          # re-create the archive with the signed & stapled artifact
          # create the zip file with predictable timestamps
          TAGDATE="$(git log -1 --format=%ad --date=iso-strict ${GITHUB_REF#refs/tags/})"
          find "staging/Payload" -exec touch -d "${TAGDATE:0:19}" {} \;

          ditto -c -k --sequesterRsrc --keepParent "staging/Payload" "staging/${FAIR_APP_ARTIFACT}-iOS.ipa"
          ls -la "staging/${FAIR_APP_ARTIFACT}-iOS.ipa"
          shasum -a 256 "staging/${FAIR_APP_ARTIFACT}-iOS.ipa"


      - name: "Replicate sealed iOS build"
        if: steps.platforms.outputs.ios == 'enabled'
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}
        run: |
          # build the URL for the GitHub download artifact
          IPAURL="https://${HUB_REPO}/${ORGNAME}/App/releases/download/${APP_VERSION}/${FAIR_APP_ARTIFACT}-iOS.ipa" 

          echo "Generating fairseal for: $IPAURL"

          mkdir staging/.artifact_stash/
          mv -f staging/*.zip staging/.artifact_stash/ || true # don't seal the macOS zip for iOS seal

          mkdir -p staging/untrusted/

          $FAIRTOOL fair fairseal \
            --verbose \
            --hub "${HUB_REPO}/${{ inputs.fairground }}" \
            --base-repo "App" \
            --post-issue "${{ github.event.number }}" \
            --token "${{ secrets.APP_FAIR_BOT_TOKEN }}" \
            --org "${ORGNAME}" \
            --fairseal-key "${{ secrets.APP_FAIR_FAIRSEAL_KEY }}" \
            --trusted-artifact "staging/${FAIR_APP_ARTIFACT}-iOS.ipa" \
            --untrusted-artifact "staging/untrusted/${FAIR_APP_ARTIFACT}-iOS.ipa" \
            --disassembler=/usr/bin/otool \
            --permitted-diffs 0 \
            --retry-duration 3600 \
            --artifact-url "$IPAURL" \
            --artifact-staging "staging/" \
            --fair-properties "$FAIRGROUND.xcconfig" \
            --accent-color "Assets.xcassets/AccentColor.colorset/Contents.json" \
            --project . \
            --metadata "App.yml"

          mv -f staging/.artifact_stash/* staging/ || true # restore stash

      - name: "Check PreFlight Eligibility"
        id: preflight
        if: env.TESTFLIGHT_TEAMID != ''
        env:
          TESTFLIGHT_TEAMID: ${{ secrets.TESTFLIGHT_TEAMID }}
        run: |
          echo "::set-output name=defined::true"
          # check the 'TESTFLIGHT_APP_ID' key in $FAIRGROUND.xcconfig
          echo "::set-output name=testflight::$(cat App.yml | yq -r '.markets.testflight')"
          echo "::set-output name=testflighturl::$(cat App.yml | yq -r '.markets.testflighturl' | sed 's;^null$;;g')"

      - name: "Prepare PreFlight"
        if: steps.preflight.outputs.testflight > 0
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}
          TESTFLIGHT_TEAMID: ${{ secrets.TESTFLIGHT_TEAMID }}
          TESTFLIGHT_ISSUER_ID: ${{ secrets.TESTFLIGHT_ISSUER_ID }}
          TESTFLIGHT_KEY_ID: ${{ secrets.TESTFLIGHT_KEY_ID }}
          TESTFLIGHT_KEY_CONTENTS: ${{ secrets.TESTFLIGHT_KEY_CONTENTS }}
          TESTFLIGHT_CODESIGNING_IDENTITY: ${{ secrets.TESTFLIGHT_CODESIGNING_IDENTITY }}
          FASTLANE_OPT_OUT_USAGE: 1
        run: |
          # Setup the keychain and import the signing cert
          security delete-keychain appstore.keychain || true
          security create-keychain -p "${{ secrets.TESTFLIGHT_CERTKEY_PASSWORD }}" appstore.keychain
          security default-keychain -s appstore.keychain
          security list-keychains -s appstore.keychain

          # import certificate
          mkdir -p .signing
          echo "${{ secrets.TESTFLIGHT_CERTKEY_P12_BASE64 }}" | base64 -d -o .signing/certificate.p12
          security import .signing/certificate.p12 -k appstore.keychain -A -P "${{ secrets.TESTFLIGHT_CERTKEY_PASSWORD }}"
          rm -rf .signing

          security set-key-partition-list -S "apple-tool:,apple:,codesign:" -s -k "${{ secrets.TESTFLIGHT_CERTKEY_PASSWORD }}" appstore.keychain

          # show valid identities
          security find-identity -v

          # if we have the public URL set then automatically distibute
          if [ "${{ steps.preflight.outputs.testflighturl }}" = "null" ]; then
            FAIR_APP_DISTRIBUTE_EXTERNAL="false"
          else
            FAIR_APP_DISTRIBUTE_EXTERNAL="true"
          fi

          mkdir -p fastlane/metadata/

          cat > fastlane/Fastfile << EOF
          opt_out_usage

          lane :setup do
            setup_ci if ENV['CI']
            app_store_connect_api_key({
              key_id: ENV['TESTFLIGHT_KEY_ID'],
              issuer_id: ENV['TESTFLIGHT_ISSUER_ID'],
              key_content: ENV['TESTFLIGHT_KEY_CONTENTS'],
            })
          end

          lane :provision do
            setup
            get_provisioning_profile({
              platform: ENV['FASTLANE_PROFILE_PLATFORM'],
              app_identifier: "${PREFLIGHT_BUNDLE_PREFIX}.${BUNDLE_ID}",
              force: true,
              fail_on_name_taken: false,
              filename: "fastlane/embedded.mobileprovision"
            })
            update_project_provisioning({
              xcodeproj: "project.xcodeproj",
            })
          end

          lane :metadata do
            setup
            upload_to_app_store({
              force: true, # Set to true to skip verification of HTML preview
              app_identifier: "${PREFLIGHT_BUNDLE_PREFIX}.${BUNDLE_ID}",
              run_precheck_before_submit: false,
              use_live_version: false,
              edit_live: false, # this option disables ipa upload and screenshot upload
              overwrite_screenshots: true,
              sync_screenshots: true,
              submit_for_review: false,
              skip_screenshots: false,
              #skip_screenshots: false,
              skip_metadata: false,
              ignore_language_directory_validation: false,
              screenshots_path: "fastlane/screenshots/",
              metadata_path: "fastlane/metadata/",
              #app_rating_config_path: "fastlane/rating_config.json",
            })
          end

          lane :beta do
            setup
            provision
            #metadata
            upload_to_testflight({
              ipa: "staging/rebundled/${FAIR_APP_ARTIFACT}-iOS.ipa",
              skip_submission: false,

              skip_waiting_for_build_processing: false,
              distribute_external: ${FAIR_APP_DISTRIBUTE_EXTERNAL},

              changelog: "Bug fixes and performance improvements.",
              groups: [
                "Beta"
              ]
            })
          end
          EOF

          # copy over the app icon
          cp -v "staging/${FAIR_APP_ARTIFACT}.png" fastlane/metadata/app_icon.png

          # Export the metadata from the App.yml into fastlane's metadata folder
          mkdir -p fastlane/metadata/

          # set some default review metadata
          echo "https://${HUB_REPO}/${ORGNAME}/App/discussions" > fastlane/metadata/support_url.txt
          #echo "https://${ORGNAME}.${HUB_PAGE}/App" > fastlane/metadata/marketing_url.txt
          echo "https://${ORGNAME}.appfair.net" > fastlane/metadata/marketing_url.txt

          # fetch the screenshots zip and unpack
          curl -fvSL -O "https://${HUB_REPO}/${ORGNAME}/App/releases/download/${APP_VERSION}/${FAIR_APP_ARTIFACT}-iOS-screenshots.zip" 
          unzip "${FAIR_APP_ARTIFACT}-iOS-screenshots.zip" -d fastlane/
          ls -la fastlane/
          ls -la fastlane/screenshots/
          du -skh fastlane/screenshots/
          find fastlane/screenshots/ -type f

          # remove the symbolic links to the other screenshots,
          # which is how identical shots are identified in the zip.
          # If we don't clear them out, then the fastlane upload times out.
          echo "Clearing linked localized screenshots"
          find fastlane/screenshots/ -type l -exec rm -v {} \;

          $FAIRTOOL fair metadata \
            --key "app" \
            --override "support_url=https://${HUB_REPO}/${ORGNAME}/App/issues" \
            --override "marketing_url=https://${ORGNAME}.appfair.net" \
            --override "privacy_url=https://www.appfair.net/privacy" \
            --override "first_name=App" \
            --override "last_name=Fair" \
            --override "email_address=appreview@appfair.org" \
            --override "phone_number=+44 844 209 0611" \
            --override "copyright=$(date +%Y) The App Fair Project and Contributors" \
            --append "description=\n\nThis app is a free and open-source program developed through the App Fair Project by contributors from around the world and distributed under the Affero General Public License. Learn more at appfair.org." \
            --append "fr-FR/description=\n\nCe app is a free and open-source program developed through the App Fair Project by contributors from around the world and distributed under the Affero General Public License. Learn more at appfair.org." \
            --export fastlane/metadata App.yml

          FASTLANE_ENABLE_BETA_DELIVER_SYNC_SCREENSHOTS=1 fastlane metadata

      - name: "PreFlight iOS"
        if: steps.preflight.outputs.testflight > 0
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}
          TESTFLIGHT_TEAMID: ${{ secrets.TESTFLIGHT_TEAMID }}
          TESTFLIGHT_ISSUER_ID: ${{ secrets.TESTFLIGHT_ISSUER_ID }}
          TESTFLIGHT_KEY_ID: ${{ secrets.TESTFLIGHT_KEY_ID }}
          TESTFLIGHT_KEY_CONTENTS: ${{ secrets.TESTFLIGHT_KEY_CONTENTS }}
          TESTFLIGHT_CODESIGNING_IDENTITY: ${{ secrets.TESTFLIGHT_CODESIGNING_IDENTITY }}
          FASTLANE_PROFILE_PLATFORM: ios
          FASTLANE_DESTINATION: generic/platform=iOS
          FASTLANE_OPT_OUT_USAGE: 1
          PLATFORM_NAME: iphoneos
          SUPPORTED_PLATFORMS: iphoneos
          CI: true
        run: |
          # already installed on CI, but this will update any hotfixes
          gem install fastlane

          # log the environment
          fastlane env

          # acquire embedded.mobileprovision
          fastlane provision --verbose

          #$FAIRTOOL app rebundle --export fastlane/metadata App.yml

          # Re-sign the validated ipa
          mkdir -p staging/rebundled/
          cd staging/rebundled/

          # Extract the untrusted ipa we downloaded for the fairseal
          unzip -q "../untrusted/${FAIR_APP_ARTIFACT}-iOS.ipa"

          # Re-parent the bundle ID with the prefix
          # TODO: need to also replace all extension bundle IDs
          plutil -replace 'CFBundleIdentifier' -string "${PREFLIGHT_BUNDLE_PREFIX}.${BUNDLE_ID}" "Payload/${PRODUCT_NAME}.app/Info.plist"

          cp "../../fastlane/embedded.mobileprovision" "Payload/${PRODUCT_NAME}.app/embedded.mobileprovision"

          # sign both the frameworks and the parent app
          SIGNID=$(security find-identity -v | cut -f 4 -d ' ' | head -n 1)
         
          # add: application-identifier = <string>${TESTFLIGHT_TEAMID}.${PREFLIGHT_BUNDLE_PREFIX}.${BUNDLE_ID}</string>
          plutil -replace 'application-identifier' -string "${TESTFLIGHT_TEAMID}.${PREFLIGHT_BUNDLE_PREFIX}.${BUNDLE_ID}" "../../sandbox-ios.entitlements"

          codesign --force -v --options runtime --generate-entitlement-der --preserve-metadata="identifier,entitlements,flags" -s "${SIGNID}" "Payload/${PRODUCT_NAME}.app"/Frameworks/*.framework
          codesign --entitlements "../../sandbox-ios.entitlements" --force -v --options runtime --generate-entitlement-der --preserve-metadata="identifier,entitlements,flags" -s "${SIGNID}" "Payload/${PRODUCT_NAME}.app"

          # re-create the archive with the signed app for submission
          ditto -c -k --sequesterRsrc --keepParent "Payload" "${FAIR_APP_ARTIFACT}-iOS.ipa"

          rm -rf Payload/

          cd -

          fastlane beta --verbose

          # TODO: separate build and uploads phases
          #fastlane pilot upload
          #fastlane deliver --skip_screenshots --force

          #cp $FAIRGROUND.xcconfig $FAIRGROUND.xcconfig.clean
          #mv $FAIRGROUND.xcconfig.clean $FAIRGROUND.xcconfig

      - name: "Archive macOS App"
        if: steps.platforms.outputs.macos == 'enabled'
        run: |
          # needed to be able to ad-hoc codesign embedded frameworks
          plutil -replace 'com\.apple\.security\.cs\.disable-library-validation' -bool true ReleasePR/sandbox-macos.entitlements

          set -o pipefail && env NSUnbufferedIO=YES \
          xcodebuild archive \
            -workspace "App.xcworkspace" \
            -jobs 1 \
            -configuration Release \
            -scheme "${APP_TARGET}" \
            -sdk "macosx" \
            -destination "platform=macOS" \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-macOS.xcarchive" \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES \
            AD_HOC_CODE_SIGNING_ALLOWED=YES \
            CODE_SIGN_IDENTITY="-" \
            DEVELOPMENT_TEAM="" \
            CODE_SIGN_IDENTITY="-" \
            OTHER_CODE_SIGN_FLAGS="--deep --timestamp=none" \
            OTHER_LIBTOOLFLAGS="-D" \
            FAIRAPP_PRODUCT_NAME="${PRODUCT_NAME}" \
            | xcpretty

          shasum -a 256 "staging/.${FAIR_APP_ARTIFACT}-macOS.xcarchive/Products/Applications"/*.app/Contents/MacOS/*

          echo '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict><key>method</key><string>mac-application</string><key>signingStyle</key><string>automatic</string></dict></plist>' > "staging/exportOptions.plist"

          xcodebuild \
            -exportArchive \
            -archivePath "staging/.${FAIR_APP_ARTIFACT}-macOS.xcarchive" \
            -exportPath "staging/" \
            -exportOptionsPlist "staging/exportOptions.plist"

          codesign --verify --verbose=5 "staging/${PRODUCT_NAME}.app"
          codesign -dv --verbose=5 "staging/${PRODUCT_NAME}.app"
          codesign -d --entitlements - "staging/${PRODUCT_NAME}.app"


          ditto -c -k --sequesterRsrc --keepParent "staging/${PRODUCT_NAME}.app" "staging/${FAIR_APP_ARTIFACT}-macOS.zip"

          # show the binary checksum
          openssl sha256 "staging/${PRODUCT_NAME}.app/Contents/MacOS/"*
          openssl sha256 "staging/${FAIR_APP_ARTIFACT}-macOS.zip"

          rm -rf "staging/${PRODUCT_NAME}.app" # cleanup


      # compare the contents of the PR's un-trusted artifacts with
      # the contents of the base fair-ground's trusted artifacts
      - name: "Replicate sealed macOS build"
        if: steps.platforms.outputs.macos == 'enabled'
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}

        run: |
          # build the URL for the GitHub download artifact
          ZIPURL="https://${HUB_REPO}/${ORGNAME}/App/releases/download/${APP_VERSION}/${FAIR_APP_ARTIFACT}-macOS.zip" 

          echo "Generating fairseal for: $ZIPURL"

          mkdir -p staging/untrusted/
          mkdir -p staging/.artifact_stash/

          mv -f staging/*.ipa staging/.artifact_stash/ || true # don't seal the ipa when sealing macOS


          # if the builds match, we indicate success by publishing the 
          # "fairseal" manifest as a comment on the release's pull request;
          # client apps will use this hash to verify that the untrusted
          # release artifact that is downloaded matches the release
          # artifact that was created in the trusted environment
          $FAIRTOOL fair fairseal \
            --verbose \
            --hub "${HUB_REPO}/${{ inputs.fairground }}" \
            --base-repo "App" \
            --post-issue "${{ github.event.number }}" \
            --token "${{ secrets.APP_FAIR_BOT_TOKEN }}" \
            --org "${ORGNAME}" \
            --fairseal-key "${{ secrets.APP_FAIR_FAIRSEAL_KEY }}" \
            --trusted-artifact "staging/${FAIR_APP_ARTIFACT}-macOS.zip" \
            --untrusted-artifact "staging/untrusted/${FAIR_APP_ARTIFACT}-macOS.zip" \
            --disassembler=/usr/bin/otool \
            --permitted-diffs 0 \
            --retry-duration 3600 \
            --artifact-url "$ZIPURL" \
            --artifact-staging "staging/" \
            --fair-properties "$FAIRGROUND.xcconfig" \
            --accent-color "Assets.xcassets/AccentColor.colorset/Contents.json" \
            --project . \
            --metadata "App.yml"

          mv -f staging/.artifact_stash/* staging/ || true # restore stash

      - name: "Publish Catalog"
        env:
          GITHUB_TOKEN: ${{ secrets.APP_FAIR_BOT_TOKEN }}
        run: |
          gh workflow --repo "${{ inputs.fairground }}/${{ inputs.fairground }}.${HUB_PAGE}" run "catalog.yml"

      - name: "Upload Build Artifacts"
        # upload the trusted artifacts for each build for reproducible-builds
        uses: actions/upload-artifact@v2
        if: always()
        with:
          path: staging

